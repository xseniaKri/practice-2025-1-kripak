# Пошаговое руководство: как создать телеграм-бота
В этом руководстве описан процесс разработки Telegram-бота для проведения интерактивной викторины. Цель проекта — познакомить читателя с основами работы с Telegram API и библиотекой Aiogram, а также показать пример организации асинхронного взаимодействия и управления состояниями пользователя.

## Последовательность действий по исследованию предметной области

Перед началом реализации Telegram-бота необходимо выполнить ряд шагов по исследованию предметной области:

1. **Определить цель проекта**
   Необходимо чётко сформулировать, какую задачу должен решать Telegram-бот. В данном случае — предоставить пользователю возможность пройти короткий тест (викторину) для определения уровня владения английским языком и получения результата в удобной форме.

2. **Анализировать целевую аудиторию и сценарии взаимодействия**
   Необходимо представить, как пользователь будет взаимодействовать с ботом. Требуется проработать сценарии: запуск бота, принятие или отказ от участия, прохождение теста, получение результатов.

3. **Изучить возможности Telegram API и библиотеки Aiogram**
   Необходимо ознакомиться с Telegram Bot API и инструментами работы с ним — в частности, с библиотекой **Aiogram**. Следует понять, как обрабатывать команды, использовать инлайн-кнопки, настраивать FSM (машину состояний) и взаимодействовать с callback-запросами.

4. **Выбрать технологию реализации**
   Необходимо определить, какие библиотеки и архитектурные подходы будут использоваться в проекте. Aiogram следует выбрать как асинхронный, современный фреймворк, подходящий для создания FSM-бота.

5. **Проанализировать существующие решения (аналоги)**
   Необходимо изучить Telegram-ботов со схожим функционалом, чтобы выявить успешные практики, оценить интерфейс, способы оформления вопросов и способы отображения результатов.

6. **Спроектировать структуру проекта**
   Требуется определить основные модули проекта: обработка команд, логика викторины, работа с состояниями пользователя, генерация клавиатур, подключение к базе данных. Также необходимо спланировать способ хранения и обработки тестовых вопросов.

7. **Сформулировать требования к функциональности**
   Необходимо определить набор функций, которые должен выполнять бот:

   * реагировать на команду `/start`;
   * отображать приветственное сообщение;
   * запускать викторину;
   * последовательно отправлять вопросы с кнопками;
   * проверять ответы и считать баллы;
   * отображать результат и уровень;
   * ограничивать возможность повторного прохождения теста.

---

## Подготовка к разработке

### 1. Подготовка среды разработки

Перед началом разработки потребуется:

* Установить интерпретатор Python последней версии (например, Python 3.10 или выше).
* Настроить виртуальное окружение для управления зависимостями проекта.
* Создать новую директорию проекта и инициализировать её как рабочую директорию.
* Установить необходимые зависимости:
    * aiogram>=3.0.0
    * aiohttp==3.9.3
    * asyncpg
    * requests==2.31.0
    * python-dotenv==1.1.0



### 2. Регистрация бота

Для создания Telegram-бота потребуется:

* В Telegram найти и использовать официального бота **@BotFather**.
* Запустить команду создания нового бота.
* Указать имя и уникальный username.
* Получить токен — уникальный ключ доступа к API, который впоследствии будет использован в коде.

---

## Структура проекта

Далее нужно сформировать базовую структуру проекта, например:
```
quiz_bot/
├── data/
│   └── questions.json      # вопросы викторины
├── keyboards/
│   └── quiz_kb.py          # клавиатуры
├── handlers/
│   └── quiz_handler.py     # логика викторины
├── main.py                 # запуск бота
├── create-bot.py               # создание и настройки бота
├── requirements.txt        # зависимости
```

Такая структура позволит упростить поддержку и расширение функциональности.

---

## Формат хранения данных

Вопросы викторины можно хранить во внешнем файле в формате JSON. Это позволит:

* Упрощённо редактировать и дополнять базу вопросов;
* Хранить каждый вопрос как объект с текстом, списком вариантов и правильным ответом;
* Гибко масштабировать количество заданий.

---

## Реализация пользовательского интерфейса

Для взаимодействия пользователя с ботом стоит использоваться инлайн-клавиатуры. Они позволят:

* Отображать варианты ответов непосредственно под вопросом;
* Позволить пользователю выбрать ответ одним нажатием;
* Получать callback-событие от Telegram и обрабатывать его.

Эти клавиатуры позволит создать библиотека Aiogram. В ней инлайн-клавиатуры работают следующим образом:

- Создаётся объект клавиатуры (`InlineKeyboardMarkup`).
- В клавиатуру добавляются кнопки (`InlineKeyboardButton`), каждая с текстом и уникальным callback-данными.
- Когда пользователь нажимает кнопку, бот получает callback-запрос с этими данными.
- Бот обрабатывает callback и выполняет нужное действие (например, проверяет ответ викторины).

Далее показан пример создания и обработки инлайн-клавиатуры

```python
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor

API_TOKEN = 'YOUR_BOT_TOKEN'

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# Создание инлайн-клавиатуры с двумя кнопками
inline_kb = InlineKeyboardMarkup(row_width=2)
btn1 = InlineKeyboardButton("Ответ 1", callback_data="answer_1")
btn2 = InlineKeyboardButton("Ответ 2", callback_data="answer_2")
inline_kb.add(btn1, btn2)

# Обработчик, срабатывает по нажатию команды старт
@dp.message_handler(commands=['start'])
async def send_welcome(message: types.Message):
    await message.answer("Выберите правильный ответ:", reply_markup=inline_kb)

# Обработчик, страбатывает по нажатию на кнопку
@dp.callback_query_handler(lambda c: c.data and c.data.startswith('answer_'))
async def process_callback(callback_query: types.CallbackQuery):
    answer = callback_query.data  # например, 'answer_1'
    if answer == "answer_1":
        response = "Правильно!"
    else:
        response = "Неправильно!"
    await bot.answer_callback_query(callback_query.id, text=response)
    await bot.send_message(callback_query.from_user.id, response)

if __name__ == '__main__':
    executor.start_polling(dp)
```
---

## Логика викторины

Необходимо продумать бизнес-логику. Основные этапы работы бота будут включать:

1. Приём команды от пользователя (например, `/start` или `/quiz`);
2. Загрузка первого вопроса из списка;
3. Последовательный вывод вопросов с возможностью выбора ответа;
4. Подсчёт количества правильных ответов;
5. Отображение итогового результата.

Нужно реализовать механизм отслеживания состояния пользователя, чтобы знать, на каком вопросе он находится и какой результат набрал - это делается при помощи FSMContext и States.
Все эти инструменты предоставляет библиотека Aiogram, в ее [документации](https://docs.aiogram.dev/en/v3.20.0.post0/) есть также примеры кода, по ним можно легко реализовать все необходимые функции.
Ниже приведены примеры хендлеров для старта и самой викторины:
```python
# Обработчик команды или сообщения, чтобы начать викторину
@quiz_router.message()
async def start_quiz_handler(message: types.Message, state: FSMContext):
    data = await state.get_data()
    # Проверяем, проходил ли пользователь уже тест
    if data.get("completed"):
        await message.answer(text="Вы уже прошли тест!")
        return

    # Инициализируем состояние и счетчики
    await state.set_state(Quiz.question)
    await state.update_data(current_question=0, correct_answers=0)

    await message.answer(
        text=(
            "Супер! Тогда начнем.\n"
            "Время прохождения: 3-5 минут.\n"
            "Выбирайте из предложенных кнопок, поскольку текст с обычной клавиатуры не воспринимается тестом.\n"
        )
    )
    # Отправляем первый вопрос
    await send_question(message, state)

# Функция отправки вопроса с клавиатурой вариантов ответа
async def send_question(message: types.Message | types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    idx = data.get("current_question", 0)  # Текущий индекс вопроса
    question = questions[idx]

    # Отправляем текст вопроса с кнопками вариантов ответа
    await message.answer(
        text=question['text'],
        reply_markup=generate_keyboard(question['options'])
    )

# Обработчик выбора варианта ответа по callback
@quiz_router.callback_query(Quiz.question)
async def handle_answer(callback: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    idx = data.get("current_question", 0)
    correct = data.get("correct_answers", 0)

    user_answer = callback.data  # Выбранный пользователем ответ
    question = questions[idx]

    # Проверяем ответ и сообщаем пользователю
    if user_answer == question["correct"]:
        correct += 1
        await callback.message.answer("Правильно!")
    else:
        await callback.message.answer("Неправильно!")

    idx += 1  # Переходим к следующему вопросу

    # Если вопросы закончились — показываем итог и очищаем состояние
    if idx == len(questions):
        await handle_end(callback=callback, correct=correct)
        await state.clear()  # Очистить состояние
        await state.update_data(completed=True)  # Отметить, что тест пройден
    else:
        # Обновляем данные в состоянии и отправляем следующий вопрос
        await state.update_data(current_question=idx, correct_answers=correct)
        await send_question(callback.message, state)

# Функция обработки конца викторины и вывода результата
async def handle_end(callback: types.CallbackQuery, correct: int) -> None:
    # Определяем уровень пользователя по количеству правильных ответов
    if correct in [0, 1, 2]:
        level = "A0"
    elif correct in [3, 4]:
        level = "A1"
    elif correct in [5, 6]:
        level = "A2"
    elif correct in [7, 8]:
        level = "B1"
    else:
        level = "B2"

    # Правильное окончание слова "балл"
    if correct in [0, 5, 6, 7, 8, 9, 10]:
        end = "ов"
    elif correct == 1:
        end = ""
    else:
        end = "а"

    # Отправляем итоговое сообщение пользователю
    await callback.message.answer(
        text=(
            f"Поздравляю с прохождением теста! "
            f"Вы набрали {correct} балл{end}\n"
            f"Ваш уровень: {level}."
        )
```


---
## Обработка событий
Для организации логики обработки входящих сообщений и событий в Aiogram используются механизмы Dispatcher и Router.

**Dispatcher** — это основной компонент, который будет получать все входящие обновления от Telegram и направлять их нужным обработчикам. Его задачей будет:

- Слушать сообщения, команды и другие события;
- Определять, какой обработчик должен сработать;
- Управлять потоком данных между пользователем и логикой бота.

Таким образом, `Dispatcher` будет выступать в роли центра обработки событий, через который будет проходить вся логика.

**Router** — это более современный и модульный способ организации логики, появившийся в Aiogram 3.x. Он позволит разделить разные части логики на независимые блоки, каждая будет содержать хендлер - обработчик событий (примеры приведены выше). Например:

<img src="https://github.com/user-attachments/assets/4ea3940a-f6cd-4160-981f-6b56c6c63fa2" width="100%" height="100%">

При необходимости в будущем масштабирования проекта использование Router сделает код более читаемым и структурированным.

## Настройка маршрутизации событий

Для корректной работы с Telegram API потребуется:

* Настроить диспетчер сообщений (`Dispatcher`), который будет слушать команды и callback-запросы;
* Зарегистрировать обработчики команд и ответов;
* Обеспечить запуск бота через метод `executor.start_polling`.

Можно выбрать вариант через технологию webhook, но он более сложен в реализации и требует выделенного IP-адреса, и установленного SSL на сервере.
Поэтому рекомендуется использовать технологию Long Polling - сервер с логикой телеграм-бота (наша хост машина) будет выступать в качестве клиента и регулярно опрашивать сервер Telegram на появление новых событий в боте.

<img src="https://github.com/user-attachments/assets/28756735-edcb-48a3-a8fb-9d4f7c80920c" width="30%" height="30%">

---

## Тестирование

После реализации всех компонентов потребуется:

* Запустить бота в локальной среде;
* Проверить корректность отображения вопросов и обработки ответов;
* Убедиться, что результаты викторины подсчитываются корректно.

---

## Заключение

В результате реализации описанных шагов будет создан Telegram-бот, способный проводить викторину в интерактивном формате. Такой проект послужит хорошей основой для дальнейшего изучения Telegram API, асинхронного программирования и разработки пользовательских сервисов.

---
## Модификация проекта

В качестве модификации мной был добавлен функционал сохранения результатов пользователя в базу данных и выдача этих результатов в JSON-формате по запросу. Для этого была создана БД при помощи PostgreSQL со следующей схемой:
![изображение](https://github.com/user-attachments/assets/5215d591-311f-4eb7-902e-147fac61c7a9)
Далее был написан простой веб-сервер с использованием FastAPI (файл webserver.py), который по запросу ```localhost://database``` показывает содержимое этой базы данных.
